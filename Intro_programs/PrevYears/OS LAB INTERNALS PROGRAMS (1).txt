#!/bin/bash
#Shell Script to check whether the number is palindrome or not

echo "Enter any number: "
read num

sum=0
temp=$num
while [ $num -gt 0 ]
do
    r=$((num%10))
    sum=$((sum*10+r))
    num=$((num/10))
done
echo "Number after reversing: $sum"
if [ $temp == $sum ];then
    echo "$temp is a palindrome"
else
    echo "$temp is not palindrome"
fi
***************************************************************************************************
#!bin/bash
#Shell script to check whether a given string is a palindrome or not(bash Palindrome.sh)
#the reverse of the string using inbuilt function
echo -ne "Enter a string: "
read str1
echo -ne "The reversed string is: "
echo $str1 | rev
length=${#str1}

#Generic reversal method through looping to find the reverse of string and check for palindrome"
for((i=$length-1; i>=0; i--))
do
    REV=$REV${str1:$i:1}
done
echo -ne "The reverse of the string using looping is : "
echo $REV
if [ $str1 == $REV ]
then
    echo "$str1 is a palindrome"
else
    echo "$str1 is not a palindrome"
fi

***************************************************************************************************
/*  C program to implement SJF(Preemptive) CPU Scheduling Algorithm
    Name of the program: SJFPreemptive.c
*/

#include<stdio.h>
#include<stdbool.h>
#include<limits.h>

struct Process
{
    int PID;
    unsigned int ArrivalTime;
    unsigned int BurstTime;
    unsigned int StartTime;
    unsigned int CompletionTime;
    unsigned int TurnAroundTime;
    unsigned int WaitingTime;
    unsigned int ResponseTime;
};

unsigned int CurrentTime = 0;  //To track current time of execution
unsigned int Completed = 0; //To track number of processes that has completed its execution at a particular point of time
bool IsFirstProcess = true;
int MinIndex;//To store index of the process having least burst time at current time
int MinimumBurstTime;//To store actual CPU burst time at current time

float SumTurnAroundTime = 0, SumWaitingTime = 0, SumResponseTime = 0, TotalCPUIdleTime = 0, PreviousProcessCompletionTime = 0, LengthCycle, CPUUtilization;

int FindMax(int a, int b)
{
    return a > b ? a : b;
}

int FindMin(int a, int b)
{
    return a < b ? a : b;
}

void CTTaTWTRT(struct Process P[],int n, bool IsCompleted[])
{
    P[MinIndex].CompletionTime = CurrentTime;
    P[MinIndex].TurnAroundTime = P[MinIndex].CompletionTime - P[MinIndex].ArrivalTime;
    P[MinIndex].WaitingTime = P[MinIndex].TurnAroundTime - P[MinIndex].BurstTime;
    P[MinIndex].ResponseTime = P[MinIndex].StartTime - P[MinIndex].ArrivalTime;       
    SumTurnAroundTime += P[MinIndex].TurnAroundTime;
    SumWaitingTime += P[MinIndex].WaitingTime;
    SumResponseTime += P[MinIndex].ResponseTime;
    Completed++;
    IsCompleted[MinIndex] = true;
}

void FindMinimumBurstTimeProcess(struct Process P[],int n, bool IsCompleted[], int BurstTimeRemaining[])
{
    while(Completed != n)
    {
        //Find process with Minuimum Burst Time in ready queue at current time
        MinIndex = -1;
        MinimumBurstTime = INT_MAX;
        for(int i = 0; i < n; i++) 
        {
            if(P[i].ArrivalTime <= CurrentTime && IsCompleted[i] == false) 
            {
                if(BurstTimeRemaining[i] < MinimumBurstTime)
                {
                    MinimumBurstTime = BurstTimeRemaining[i];
                    MinIndex = i;
                }
                if(BurstTimeRemaining[i] == MinimumBurstTime)
                {
                    if(P[i].ArrivalTime < P[MinIndex].ArrivalTime)
                    {
                        MinimumBurstTime = BurstTimeRemaining[i];
                        MinIndex = i;
                    }
                }
            }
        }
        if(MinIndex == -1)
        {
            printf("|idle ");
            CurrentTime++;
        }
        else
        {
            if(BurstTimeRemaining[MinIndex] == P[MinIndex].BurstTime)
            {
                P[MinIndex].StartTime = CurrentTime;
                TotalCPUIdleTime += (IsFirstProcess == true) ? P[MinIndex].ArrivalTime : (P[MinIndex].StartTime -  PreviousProcessCompletionTime);
                IsFirstProcess = false;
            }
            printf("|P%d(1)%d ",P[MinIndex].PID, CurrentTime+1);
            BurstTimeRemaining[MinIndex] -= 1;
            CurrentTime++; 
            PreviousProcessCompletionTime = CurrentTime;
            if(BurstTimeRemaining[MinIndex] == 0)
            {
                CTTaTWTRT(P, n, IsCompleted);
                
            }
        }
    }
}

void ProcessDetails(struct Process P[],int n, bool IsCompleted[], int BurstTimeRemaining[])
{
    for(int i = 0; i < n; i++)
    {
        printf("\nEnter Process-ID: "); scanf("%d",&P[i].PID);
        printf("Enter Arrival Time: "); scanf("%d",&P[i].ArrivalTime);
        printf("Enter CPU Burst Time: "); scanf("%d",&P[i].BurstTime);
        IsCompleted[i] = false;
        BurstTimeRemaining[i] = P[i].BurstTime;
    }
}

void Display(struct Process P[],int n)
{
    int MaxCompletionTime = INT_MIN;
    int MinArrivalTime = INT_MAX;
    for(int i = 0; i < n; i++)
    {
        MaxCompletionTime = FindMax(MaxCompletionTime, P[i].CompletionTime);
        MinArrivalTime = FindMin(MinArrivalTime, P[i].ArrivalTime);
    }
    LengthCycle = MaxCompletionTime - MinArrivalTime;
    
    printf("\nProcess ID\tArrival Time\tCPU Burst Time\tCompletion Time\tTurn Around Time\tWaiting Time\tResponse Time\n");
    for(int i = 0; i < n; i++)
        printf("%d\t\t%d\t%d\t\t%d\t%d\t%d\t%d\n",P[i].PID, P[i].ArrivalTime, P[i].BurstTime, P[i].CompletionTime, P[i].TurnAroundTime, P[i].WaitingTime, P[i].ResponseTime);

    CPUUtilization = (LengthCycle - TotalCPUIdleTime) / LengthCycle;
    
    
    printf("\nAverage Turn Around time = %.2f ms",SumTurnAroundTime / n);
    printf("\nAverage Waiting Time = %.2f ms",SumWaitingTime / n);
    printf("\nAverage Response Time = %.2f ms",SumResponseTime / n);
    printf("\nThroughput = %.2f", n / LengthCycle);    
    printf("\nCPU Utilization(in Percentage) = %.2f", CPUUtilization * 100);
}

int main()
{
    int n;
    printf("Enter total number of processes: ");    scanf("%d",&n);
    struct Process P[n];
    int BurstTimeRemaining[n];
    bool IsCompleted[n];
    ProcessDetails(P,n,IsCompleted,BurstTimeRemaining);
    printf("\nGantt Chart: \n\n");
    FindMinimumBurstTimeProcess(P,n,IsCompleted,BurstTimeRemaining);
    printf("|\n\n");
    Display(P,n);
    return 0;
}

***************************************************************************************************
***************************************************************************************************
#!bin/bash
#Shell Script to generate prime numbers in a given range
echo -ne "Enter lower bound of the interval: "
read a
echo -ne "Enter upper bound of the interval: "
read b
echo -ne "Prime numbers in the range $a and $b is/are: "
for((i=$a; i<=b; i++))
do
  if [[ $i == 0 || $i == 1 ]]; then
    continue
  fi
  
  count=0
  for((j=1; j<=i; j++))
  do
    if [ $((i%j)) == 0 ]; then
      count=$((count+1))
    fi
  done
  if [ $count == 2 ]; then
    echo -ne "$i "
  fi
done
echo 

***************************************************************************************************
/*  C program to implemnt Preemptive Priority CPU scheduling algorithm
    Name of the program: PriorityPreemptive.c
*/

#include<stdio.h>

struct Process
{
    int PID, Priority;
    unsigned int ArrivalTime;
    unsigned int BurstTime;
    unsigned int StartTime;
    unsigned int CompletionTime;
    unsigned int TurnAroundTime;
    unsigned int WaitingTime;
    unsigned int ResponseTime;
}P[10];

unsigned int BurstTimeRemaining[10];

void ProcessDetails(int n)
{
    for(int i = 0; i < n; i++)
    {
        printf("\nEnter Process-ID: "); scanf("%d",&P[i].PID);
        printf("Enter Arrival Time: "); scanf("%d",&P[i].ArrivalTime);
        printf("Enter CPU Burst Time: "); scanf("%d",&P[i].BurstTime);
        printf("Enter Process Priority: "); scanf("%d",&P[i].Priority);
        BurstTimeRemaining[i] = P[i].BurstTime;
    } 
}

void SelectProcess(int n)
{
    int t, count = 0, ShortProcess;
    float TotalWaitingTime = 0, TotalTurnAroundTime = 0, AvgWaitingTime, AvgTurnAroundTime;
    
    // we initialize the burst time of a process with maximum 
    P[9].Priority = 10000;//9
    
    for(t = 0; count != n; t++)
    {
        ShortProcess = 9;//9
        for(int i = 0; i < n; i++)
            if(P[ShortProcess].Priority > P[i].Priority && P[i].ArrivalTime <= t && P[i].BurstTime > 0)
                ShortProcess = i;
                
        if(ShortProcess == 9)
        {
            printf("Idle %d",t+1);
        }
        
        P[ShortProcess].BurstTime = P[ShortProcess].BurstTime - 1;
        printf("|P%d(1) %d",P[ShortProcess].PID,(t+1));
        
        // if any process is completed
        if(P[ShortProcess].BurstTime == 0)
        {
            // If one process is completed, count increases by 1
            count++;
            P[ShortProcess].WaitingTime = t + 1 - P[ShortProcess].ArrivalTime - BurstTimeRemaining[ShortProcess];
            P[ShortProcess].TurnAroundTime = t + 1 - P[ShortProcess].ArrivalTime;
            
            // total calculation
            TotalWaitingTime += P[ShortProcess].WaitingTime;
            TotalTurnAroundTime += P[ShortProcess].TurnAroundTime;
            
        }
    }
    
    AvgWaitingTime = TotalWaitingTime / n;
    AvgTurnAroundTime = TotalTurnAroundTime / n;
    // Printing of the results
    printf("|\n\nID WT TAT\n");
    for(int i=0;i<n;i++)
    {
        printf("%d\t%d\t%d\n",P[i].PID,P[i].WaitingTime,P[i].TurnAroundTime);
    }
    
    printf("Avg waiting time is: %f\n",AvgWaitingTime);
    printf("Avg turn around time is: %f",AvgTurnAroundTime);;
}

int main()
{
    int n;
    printf("Enter number of process: ");    scanf("%d",&n);
    ProcessDetails(n);
    printf("Gantt Chart:\n\n");
    SelectProcess(n);
}

***************************************************************************************************
***************************************************************************************************
#!/bin/bash
#Shell script to find largest of n numbers, storing numbers in an array.
echo "Enter the Elements of The Array "
read -a A
max=0
for i in ${A[@]}
  do
    if [ $i -gt $max ] ; then
      max=$i
    fi
  done 

echo "Largest element in the array is : $max"

***************************************************************************************************
Round Robin
***************************************************************************************************
***************************************************************************************************
#!/bin/bash
#Shell script for addition of two matrices

#!/bin/bash
m=3
n=3
declare -A X   
declare -A Y
declare -A Z
echo "Enter the elements of the first matrix"
for((i=0;i<3;i++))
do
    for((j=0;j<3;j++))
    do
        read X[$i,$j]
    done
done


echo "Enter the elements of the second matrix"
for((i=0;i<3;i++))
do
    for((j=0;j<3;j++))
    do
        read Y[$i,$j]
    done
done

echo "The first matrix is :"
echo
for((i=0;i<3;i++))
do
    for((j=0;j<3;j++))
    do
        echo -ne " ${X[$i,$j]}"
    done
    echo
    echo
done

echo "The second matrix is:"
echo
for((i=0;i<3;i++))
do
    for((j=0;j<3;j++))
    do
        echo -ne " ${Y[$i,$j]}"
    done
    echo -e "\n"
done

echo "The result is :"
for((i=0;i<3;i++))
do
    for((j=0;j<3;j++))
    do
        Z[$i,$j]=$((X[$i,$j]+Y[$i,$j]))
        echo -ne " ${Z[$i,$j]}"
    done
    echo -e "\n"
done

***************************************************************************************************
/*  C program to implemnt Non Preemptive Priority Scheduling Algorithm
    Name of the program: PriorityNonPreemptive.c
*/

#include<stdio.h>
#include<stdbool.h>
#include<limits.h>

struct Process
{
    int PID, Priority;
     int ArrivalTime;
     int BurstTime;
     int CompletionTime;
     int TurnAroundTime;
     int WaitingTime;
     int ResponseTime;
};

int CheckArrivalTime = 0;

void ProcessDetails(struct Process P[], int n)
{
    for(int i = 0; i < n; i++)
    {
        printf("\nEnter Process-ID: "); scanf("%d",&P[i].PID);
        printf("Enter Arrival Time: "); scanf("%d",&P[i].ArrivalTime);
        printf("Enter CPU Burst Time: "); scanf("%d",&P[i].BurstTime);
        printf("Enter Process Priority: "); scanf("%d",&P[i].Priority);

        //To check arrival time of the processes are same or different
        if(i == 0)
         CheckArrivalTime = P[i].ArrivalTime;
         
        if(CheckArrivalTime != P[i].ArrivalTime)
         CheckArrivalTime = 1;
    } 
}

void SortProcessArrivalTime(struct Process P[],int n)
{
    struct Process temp;
    for(int i = 0; i < (n - 1); i++)
    {
        for(int j = i + 1; j < n; j++)
        {
            if(P[i].ArrivalTime > P[j].ArrivalTime)
            {
                temp = P[i];
                P[i] = P[j];
                P[j] = temp;
            }
        }
    }
} 
void Swap(int *b,int *c)
{
    int temp;
    temp = *c;
    *c = *b;
    *b = temp;
}
void SortProcessPID(struct Process P[],int n)
{
    struct Process temp;
    for(int i = 0; i < (n - 1); i++)
    {
        for(int j = i + 1; j < n; j++)
        {
            if(P[i].PID > P[j].PID)
            {
                temp = P[i];
                P[i] = P[j];
                P[j] = temp;
            }
        }
    }
} 

void SelectProcess(struct Process P[], int n)
{
    int CompletionTime = 0;
    float TotalWaiingTime = 0, TotalTurnAroundTime = 0, AvgWaitingTime, AvgTurnAroundTime;
    
    // If all the process are arrived at different time
    if(CheckArrivalTime == 1)
    {
        P[0].WaitingTime = P[0].ArrivalTime;
        P[0].TurnAroundTime = P[0].BurstTime - P[0].ArrivalTime;
        CompletionTime = P[0].TurnAroundTime;
        TotalWaiingTime += P[0].WaitingTime;
        TotalTurnAroundTime += P[0].TurnAroundTime;
        printf("|P%d(%d)",P[0].PID,P[0].BurstTime);

        for(int i = 1; i < n; i++)
        {
            int Min = P[i].Priority;
            for(int j = i + 1; j < n; j++)
            {
                if(Min > P[j].Priority && P[j].ArrivalTime <= CompletionTime)
                {
                    Min = P[j].Priority;
                    Swap(&P[i].PID, &P[j].PID);
                    Swap(&P[i].ArrivalTime, &P[j].ArrivalTime);
                    Swap(&P[i].BurstTime, &P[j].BurstTime);
                    Swap(&P[i].Priority, &P[j].Priority);    
                }
                
            }
            printf("|P%d(%d)",P[i].PID,P[i].BurstTime);

            P[i].WaitingTime = CompletionTime - P[i].ArrivalTime;
            TotalWaiingTime += P[i].WaitingTime;
            CompletionTime += P[i].BurstTime;
            
            // Turn Around Time of the process = CompletionTime -ArrivalTime
            P[i].TurnAroundTime = CompletionTime - P[i].ArrivalTime;
            TotalTurnAroundTime += P[i].TurnAroundTime;
            
        }
    }
    // If all the process are arrived at same time
    else
    {
        for(int i = 0; i < n; i++)
        {
            int Min = P[i].Priority;
            for(int j = i+1; j < n; j++)
            {
                if(Min > P[j].Priority && P[j].ArrivalTime <= CompletionTime)
                {
                    Min = P[j].Priority;
                    Swap(&P[i].PID, &P[j].PID);
                    Swap(&P[i].ArrivalTime, &P[j].ArrivalTime);
                    Swap(&P[i].BurstTime, &P[j].BurstTime);
                    Swap(&P[i].Priority, &P[j].Priority);
                }
                
            }
            printf("|P%d(%d)",P[i].PID,P[i].BurstTime);
            P[i].WaitingTime = CompletionTime - P[i].ArrivalTime;
            //Completion time of the process
            CompletionTime += P[i].BurstTime;
            
            // Turn Around Time of the process
            // compl-Arrival
            P[i].TurnAroundTime = CompletionTime - P[i].ArrivalTime;
            TotalWaiingTime += P[i].WaitingTime;
            TotalTurnAroundTime += P[i].TurnAroundTime;  
        }
        
    }
    
    AvgWaitingTime = TotalWaiingTime / n;
    AvgTurnAroundTime = TotalTurnAroundTime / n;
    SortProcessPID(P,n);
    // Printing of the results
    printf("|\n\nID WT TAT\n");
    for(int i=0;i<n;i++)
    {
        printf("%d\t%d\t%d\n",P[i].PID,P[i].WaitingTime,P[i].TurnAroundTime);
    }
    
    printf("Avg waiting time is: %f\n",AvgWaitingTime);
    printf("Avg turn around time is: %f",AvgTurnAroundTime);
}

int main()
{
    int n;
    printf("Enter total number of processes: ");    scanf("%d",&n);
    struct Process P[n];
    ProcessDetails(P,n);

    if(CheckArrivalTime == 1)
        SortProcessArrivalTime(P,n);
    
    printf("Gantt Chart:\n\n");
    SelectProcess(P,n);
    return 0;
    
}

***************************************************************************************************
/*  C program to demonstrate the use of I/O system calls for file I/O( read, write, open, lseek)
    Name of the program: IOSystemCallsFileIO.c
*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>

#define BUFFER_SIZE 30

int main()
{
    int fd, n;
    char buffer[BUFFER_SIZE];
    fd = open("m6.txt", O_RDWR);
    //open(const char *__file, int __oflag, int mode)
    /*path to file which you want to use; flags-O_RDONLY: read only, O_WRONLY: write only, O_RDWR: read and write, O_CREAT: create file if it doesn’t exist, O_EXCL: prevent creation if it already exists*/ 
    printf("File discriptor is %d\n", fd);
    if (fd == -1) 
    {
        printf("Failed to open file.\n");
        exit(0);
    }
    printf("Reading first 10 characters from file: \n");
    n = read(fd, buffer, 10);
    write(1, buffer, n);
    //lseek is a system call that is used to change the location of the read/write pointer of a file descriptor
    printf("\nSkipping 5 characters from current position in the file: \n");
    lseek(fd, 5, SEEK_CUR);//SEEK_CUR - the file offset shall be set to its current location plus offset.
    n = read(fd, buffer, 10);
    write(1, buffer, n);
    printf("\nGoing 10 characters before the current position in the file: \n");
    lseek(fd, -10, SEEK_CUR);
    n = read(fd, buffer, 10);
    write(1, buffer, n);
    printf("\nGoing to 5th last character in the file: \n");
    lseek(fd, -5, SEEK_END);//SEEK_END -the file offset shall be set to the size of the file plus offset*/
    n = read(fd, buffer, 7);
    write(1, buffer, 5);
    printf("\nGoing to the 3rd character in the file: \n");
    lseek(fd, 3, SEEK_SET);//SEEK_SET-the file offset shall be set to offset bytes.
    n = read(fd, buffer, 5);
    write(1, buffer, n);
    return 0;
}
***************************************************************************************************
/*  C program to implement First Come First Serve CPU Scheduling Algorithm
    Name of the program: FCFS.c
*/

#include<stdio.h>
#include<stdlib.h>

struct Process
{
    int PID;
    unsigned int ArrivalTime;
    unsigned int BurstTime;
    unsigned int StartTime;
    unsigned int CompletionTime;
    unsigned int TurnAroundTime;
    unsigned int WaitingTime;
    unsigned int ResponseTime;
};

float SumTurnAroundTime = 0, SumWaitingTime = 0, SumResponseTime = 0, TotalCPUIdleTime = 0;
float LengthCycle = 0;

void SortProcessArrivalTime(struct Process P[],int n)
{
    struct Process temp;
    for(int i = 0; i < (n - 1); i++)
    {
        for(int j = i + 1; j < n; j++)
        {
            if(P[i].ArrivalTime > P[j].ArrivalTime)
            {
                temp = P[i];
                P[i] = P[j];
                P[j] = temp;
            }
        }
    }
} 

void ProcessDetails(struct Process P[],int n)
{
    for(int i = 0; i < n; i++)
    {
        printf("\nEnter Process-ID: "); scanf("%d",&P[i].PID);
        printf("Enter Arrival Time: "); scanf("%d",&P[i].ArrivalTime);
        printf("Enter CPU Burst Time: "); scanf("%d",&P[i].BurstTime);
        
    } 
}

void SortProcessPID(struct Process P[],int n)
{
    struct Process temp;
    for(int i = 0; i < (n - 1); i++)
    {
        for(int j = i + 1; j < n; j++)
        {
            if(P[i].PID > P[j].PID)
            {
                temp = P[i];
                P[i] = P[j];
                P[j] = temp;
            }
        }
    }
} 

int FindMax(int a, int b)
{
    return a > b ? a : b;
}

void GanttChart(struct Process P[], int i)
{
    int GTChart = 0;
    if(P[0].StartTime != 0)
    {
        while(GTChart != P[0].StartTime)
        {
            printf(" ");
            GTChart++;
        }
        return;
    }
    if(P[i].StartTime == 0)
    {
        printf("|");
        printf("P%d(%d)",P[i].PID, P[i].BurstTime);
        while(GTChart != P[i].BurstTime)
        {
            printf(" ");
            GTChart++;
        }
    }
    else
    {
        printf("|");
        printf("P%d(%d)",P[i].PID, P[i].BurstTime);
        while(GTChart != P[i].BurstTime)
        {
            printf(" ");
            GTChart++;
        }
    }
    if(P[i].CompletionTime < P[i + 1].ArrivalTime)
    {
        printf("|");
        while(GTChart != (P[i + 1].ArrivalTime -  P[i].CompletionTime))
        {
            printf("  ");
            GTChart++;
        }
    }
}

void CTTaTWTRT(struct Process P[],int n)
{
    for(int i = 0; i < n; i++)
    {
        P[i].StartTime = (i == 0) ? P[i].ArrivalTime : FindMax(P[i].ArrivalTime, P[i - 1].CompletionTime);  
        P[i].CompletionTime =  P[i].StartTime + P[i].BurstTime;
        P[i].TurnAroundTime = P[i].CompletionTime - P[i].ArrivalTime;       
        P[i].WaitingTime =  (i == 0) ? 0 : (P[i].TurnAroundTime - P[i].BurstTime);
        P[i].ResponseTime =  (i == 0) ? 0 : P[i].WaitingTime;
       
        SumTurnAroundTime += P[i].TurnAroundTime;
        SumWaitingTime += P[i].WaitingTime;
        SumResponseTime += P[i].ResponseTime;
        TotalCPUIdleTime += (i == 0) ? P[i].ArrivalTime : (P[i].StartTime -  P[i-1].CompletionTime);
        GanttChart(P, i);
    }
}

void Display(struct Process P[], int n)
{
    float AvgTurnAroundTime = (SumTurnAroundTime / n);
    printf("\nAverage Turn Around Time = %.2f ms",AvgTurnAroundTime);
    float AvgWaitingTime = (SumWaitingTime / n);
    printf("\nAverage Waiting Time = %.2f ms",AvgWaitingTime);
    float AvgResponseTime = (SumResponseTime / n);
    printf("\nAverage Response Time = %.2f ms",AvgResponseTime);
    LengthCycle = P[n - 1].CompletionTime - P[0].StartTime;
    printf("\nThroughput = %.2f",(n / LengthCycle));
    float CPUUtilization = (LengthCycle - TotalCPUIdleTime) / LengthCycle * 100;
    printf("\nCPU Utilization(in Percentage) = %.2f ",CPUUtilization);
}

void DisplayTable(struct Process P[], int n)
{
    printf("\nProcess ID\tArrival Time\tCPU Burst Time\tCompletion Time\tTurn Around Time\tWaiting Time\tResponse Time\n");
    for(int i = 0; i < n; i++)
        printf("    %d\t\t    %d\t\t      %d\t\t     %d\t\t\t%d\t\t   %d\t\t    %d\n",P[i].PID, P[i].ArrivalTime ,P[i].BurstTime, P[i].CompletionTime ,P[i].TurnAroundTime, P[i].WaitingTime, P[i].ResponseTime);

    Display(P,n);
}

int main()
{
    int n;
    printf("Enter number of processes: "); scanf("%d",&n);
    struct Process P[n];
    ProcessDetails(P,n);
    SortProcessArrivalTime(P,n);
    printf("\n\nGantt Chart: \n\n");
    CTTaTWTRT(P, n);
    SortProcessPID(P,n);
    printf("|\n\n");
    DisplayTable(P,n);
   
}

***************************************************************************************************
***************************************************************************************************
/*  C program to demonstrate Zombie process
    Name of the program: Zombie.c 
*/

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() 
{
    pid_t child_pid, my_pid, parent_pid;
    child_pid = fork();
    if (child_pid < 0) 
    {
        printf("Fork failed. Exiting!\n");
        exit(0);
    }
    if (child_pid == 0) 
    {
        // Child process
        printf("[CHILD] This is the child process.\n");
        my_pid = getpid();
        parent_pid = getppid();
        printf("[CHILD] My pid is %d\n", my_pid);
        printf("[CHILD] My parent's pid is %d\n", parent_pid);
        printf("[CHILD] Exiting.\n");
        exit(0);
    } 
    else 
    {
        // Parent process
        printf("[PARENT] This is the parent process.\n");
        my_pid = getpid();
        parent_pid = getppid();
        printf("[PARENT] My pid is %d\n", my_pid);
        printf("[PARENT] My parent's pid is %d\n", parent_pid);
        printf("[PARENT] Sleeping for 10 seconds.\n");
        sleep(10);
        printf("[PARENT] Child pid = %d has ended, but it has an entry in process table. It is a zombie process.\n", child_pid);
    }
    return 0;
}

OUTPUT:
[PARENT] This is the parent process.
[PARENT] My pid is 153
[PARENT] My parent's pid is 152
[PARENT] Sleeping for 10 seconds.
[CHILD] This is the child process.
[CHILD] My pid is 157
[CHILD] My parent's pid is 153
[CHILD] Exiting.
[PARENT] Child pid = 157 has ended, but it has an entry in process table. It is a zombie process.

***************************************************************************************************
/*  C program to demonstrate Zombie process
    Name of the program: Orphan.c 
*/

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() 
{
    pid_t child_pid, my_pid, parent_pid;
    child_pid = fork();
    if (child_pid < 0) 
    {
        printf("Fork failed. Exiting!\n");
    exit(0);
    }
    if (child_pid == 0) 
    {
        // Child process
        printf("[CHILD] This is the child process.\n");
        my_pid = getpid();  
        parent_pid = getppid();
        printf("[CHILD] My pid is %d\n", my_pid);
        printf("[CHILD] My parent's pid is %d\n", parent_pid);
        printf("[CHILD] Sleeping for 10 seconds.\n");   
        sleep(10);
        printf("[CHILD] My parent ended. So I am an orphan process adopted by init process.\n");
    } 
    else 
    {
        // Parent process
        printf("[PARENT] This is the parent process.\n");
        my_pid = getpid();  
        parent_pid = getppid();
        printf("[PARENT] My pid is %d\n", my_pid);
        printf("[PARENT] My parent's pid is %d\n", parent_pid);
        printf("[PARENT] Exiting.\n");
        exit(0);
    }
    return 0;
}

OUTPUT:
[PARENT] This is the parent process.
[PARENT] My pid is 804
[PARENT] My parent's pid is 803
[PARENT] Exiting.
[CHILD] This is the child process.
[CHILD] My pid is 808
[CHILD] My parent's pid is 804
[CHILD] Sleeping for 10 seconds.

***************************************************************************************************
/*  C program to implement SJF(Non Preemptive) CPU Scheduling Algorithm
    Name of the program: SJFNonPreemptive.c
*/
#include<stdio.h>
#include<stdbool.h>
#include<limits.h>

struct Process
{
    int PID;
    unsigned int ArrivalTime;
    unsigned int BurstTime;
    unsigned int StartTime;
    unsigned int CompletionTime;
    unsigned int TurnAroundTime;
    unsigned int WaitingTime;
    unsigned int ResponseTime;
};

unsigned int CurrentTime = 0;  //To track current time of execution
unsigned int Completed = 0; //To track number of processes that has completed its execution
bool IsFirstProcess = true;
int MinIndex;//To store index of the process having least burst time at current time
int MinimumBurstTime;//To store actual CPU burst time at current time

float SumTurnAroundTime = 0, SumWaitingTime = 0, SumResponseTime = 0, TotalCPUIdleTime = 0, PreviousProcessCompletionTime = 0, LengthCycle, CPUUtilization;

int FindMax(int a, int b)
{
    return a > b ? a : b;
}

int FindMin(int a, int b)
{
    return a < b ? a : b;
}


void GanttChart(struct Process P[], int i)
{
    int GTChart = 0;
    printf("|");
    printf("P%d(%d)",P[i].PID, P[i].BurstTime);
    while(GTChart != P[i].BurstTime)
    {
        printf(" ");
        GTChart++;
    }
}

void CTTaTWTRT(struct Process P[],int n, bool IsCompleted[])
{
    P[MinIndex].StartTime = (IsFirstProcess == true) ? P[MinIndex].ArrivalTime : CurrentTime;
    P[MinIndex].CompletionTime =  P[MinIndex].StartTime +  P[MinIndex].BurstTime;
    P[MinIndex].TurnAroundTime = P[MinIndex].CompletionTime - P[MinIndex].ArrivalTime;
    P[MinIndex].WaitingTime = P[MinIndex].TurnAroundTime - P[MinIndex].BurstTime;
    P[MinIndex].ResponseTime = P[MinIndex].WaitingTime;
                  
    SumTurnAroundTime += P[MinIndex].TurnAroundTime;
    SumWaitingTime += P[MinIndex].WaitingTime;
    SumResponseTime += P[MinIndex].ResponseTime;
    TotalCPUIdleTime += (IsFirstProcess == true) ? P[MinIndex].ArrivalTime : (P[MinIndex].StartTime -  PreviousProcessCompletionTime);
        
    Completed++;
    IsCompleted[MinIndex] = true;
    CurrentTime = P[MinIndex].CompletionTime;
    PreviousProcessCompletionTime = CurrentTime;
    IsFirstProcess = false; 
    
}

void FindMinimumBurstTimeProcess(struct Process P[],int n, bool IsCompleted[])
{    
    while(Completed != n)
    {
        //Find process with Minuimum Burst Time in ready queue at current time
        MinIndex = -1;
        MinimumBurstTime = INT_MAX;
        for(int i = 0; i < n; i++)
	    {
            if(P[i].ArrivalTime <= CurrentTime && IsCompleted[i] == false) 
            {
                if(P[i].BurstTime < MinimumBurstTime)
                {
                    MinimumBurstTime = P[i].BurstTime;
                    MinIndex = i;
                }
                if(P[i].BurstTime == MinimumBurstTime)
                {
                    if(P[i].ArrivalTime < P[MinIndex].ArrivalTime)
                    {
                        MinimumBurstTime = P[i].BurstTime;
                        MinIndex = i;
                    }
                }
            }
        }
        if(MinIndex == -1)
        {
            CurrentTime++;
            printf("| ");
        }
        else
        {
            CTTaTWTRT(P,n,IsCompleted);
            GanttChart(P,MinIndex);
        }
    }
}

void ProcessDetails(struct Process P[],int n, bool IsCompleted[])
{
    for(int i = 0; i < n; i++)
    {
        printf("\nEnter Process-ID: "); scanf("%d",&P[i].PID);
        printf("Enter Arrival Time: "); scanf("%d",&P[i].ArrivalTime);
        printf("Enter CPU Burst Time: "); scanf("%d",&P[i].BurstTime);
        IsCompleted[i] = false;
    }
}

void Display(struct Process P[],int n)
{
    int MaxCompletionTime = INT_MIN;
    int MinArrivalTime = INT_MAX;
    for(int i = 0; i < n; i++)
    {
        MaxCompletionTime = FindMax(MaxCompletionTime, P[i].CompletionTime);
        MinArrivalTime = FindMin(MinArrivalTime, P[i].ArrivalTime);
    }
    LengthCycle = MaxCompletionTime - MinArrivalTime;
    printf("\nProcess-ID\tArrival Time\tCPU Burst Time\tCompletion Time\tTurn Around Time\tWaiting Time\tResponse Time\n");
    for(int i=0;i<n;i++)
     printf("    %d\t\t    %d\t\t\t%d\t\t%d\t     %d\t\t\t     %d\t\t    %d\n",P[i].PID, P[i].ArrivalTime, P[i].BurstTime, P[i].CompletionTime, P[i].TurnAroundTime, P[i].WaitingTime, P[i].ResponseTime);    
    
    CPUUtilization = (LengthCycle - TotalCPUIdleTime) / LengthCycle;

    printf("\nAverage Turn Around time= %.2f ms", (SumTurnAroundTime / n));
    printf("\nAverage Waiting Time= %.2f ms", (SumWaitingTime / n));
    printf("\nAverage Response Time= %.2f ms", (SumResponseTime / n));
    printf("\nThroughput= %.2f", (n / LengthCycle));    
    printf("\nCPU Utilization(in Percentage)= %.2f", CPUUtilization * 100);
}


int main()
{
    int n;
    printf("Enter total number of processes: ");    scanf("%d",&n); 
    struct Process P[n];   
    bool IsCompleted[n];
    ProcessDetails(P,n,IsCompleted);
    printf("\nGantt Chart:\n\n");
    FindMinimumBurstTimeProcess(P,n,IsCompleted);
    printf("|\n\n");
    Display(P,n);
    return 0;
}

***************************************************************************************************
***************************************************************************************************
/*  C program for simulation of "grep" command
    Name of the program: SimulationGrep.c
*/

#include<stdio.h>
#include<string.h>

void main()
{
    char fn[10], pat[10], temp[200];
    FILE *fp = NULL;
    printf("Enter file name: ");    scanf("%s",fn);
    printf("Enter pattern to be searched: ");   scanf("%s",pat);
    fp = fopen(fn, "r");
    while(!feof(fp))
    {
        //fgets(char *str, int n, FILE *stream) reads a line from the specified stream and stores it into the string pointed to by str. It stops when either (n-1) characters are read, the newline character is read, or the end-of-file is reached, whichever comes first.
        fgets(temp,100,fp);
        if(strstr(temp,pat))//finds the first occurrence of the substring in the string
            printf("%s",temp);
    }
    fclose(fp);
}

***************************************************************************************************
/*Write a program to generate and print Fibonacci series with the following
requirements:
- Parent program should create a child and distribute the task of generating
  Fibonacci no to its child.
- The code for generating Fibonacci no. should reside in different program.
- Child should write the generated Fibonacci sequence to a shared memory.
- Parent process has to print by retrieving the Fibonacci sequence from the shared memory.
a) Implement the above using shm_open and mmap
b) Implement the above using shmget and shmat
Note: Shared object should be removed at the end in the program.
*/

//Using shm_open and mmap
//parent.c
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

int main(int argc, char *argv[])
{
    int i, k, shm_fd;
    pid_t pid;
    int n1 , n2, n3;
    const int SIZE = 4096;
    void *ptr;
  
    if (argc > 1)
    {
        sscanf(argv[1], "%d", &i);
        if (i < 1)
        {
            printf("Error input: %d\n", i);
            return 0;
        }
    }
    else
    {
      printf("Error: not passing N in command line\n");
      exit(0);
    }
  
    pid = fork();
    if (pid == 0)// CHILD
    {   
        execlp("./fib","fib",argv[1],NULL);
    }
    else if (pid > 0)
    {
        wait(NULL);
        printf("\nPARENT: child completed\n");

        shm_fd = shm_open("OS", O_RDONLY, 0666);
        ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
        printf("Parent printing:\n");
        printf("%s ", (char *)ptr);
        shm_unlink("OS");
    }
    return 0;
}
//child.c

#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include<stdlib.h>

int main(int argc, char *argv[])
{
         int k = 2, n1, n2, n3;
         void *ptr;
         int shm_fd = shm_open("OS", O_CREAT | O_RDWR, 0666);
         ftruncate(shm_fd, 4096);
         ptr = mmap(0,4096,PROT_WRITE, MAP_SHARED, shm_fd, 0);
         printf("CHILD:\n");
         int i = atoi(argv[1]);
         n1 = 0;
         n2 = 1;
        for(int j = 0; j < i; j++)
        {
            printf("%d ",n1);
            sprintf(ptr,"%d ",n1);
            n3 = n1 + n2;
            n1 = n2;
            n2 = n3;
            ptr += strlen(ptr);
        }/*
         sprintf(ptr,"%d ",n1);
         ptr+=strlen(ptr);
         printf("%d ",n1);
         sprintf(ptr,"%d ",n2);
         ptr+=strlen(ptr);
         printf("%d ",n2);
         while (k!=i)
         {
                n3=n1+n2;
                sprintf(ptr,"%d ", n3);
                printf("%d ", n3);
                n1=n2;
                n2=n3;
                ptr += strlen(ptr);
                k++;
	        }*/
}
	
/*

Output:
$ gcc parent.c -lrt
$ gcc child.c -o fib -lrt
$ ./a.out 5
CHILD:
0 1 1 2 3
PARENT: child completed
Parent printing:
0 1 1 2 3
*/
***************************************************************************************************
***************************************************************************************************
/*  C program for simulation of "ls" command
    Name of the program: SimulationGrep.c
*/

#include<stdio.h>
#include<sys/types.h>
#include<dirent.h> 
#include<stdlib.h>

void  main(int argc, char *argv[])
{
    DIR *dp;
    struct dirent *dirp;
    if(argc < 2)
    {
        printf("\n You not passing the directory\n");
        exit(1);
    }
    if((dp=opendir(argv[1]))==NULL)
    {
        printf("\nCannot open it does't exist %s file!\n",argv[1]); 
        exit(1);
    }
    while((dirp=readdir(dp))!=NULL)
    	printf("%s\n",dirp->d_name);
    closedir(dp);
}

cc Filename.c
./a.out DirectoryName
***************************************************************************************************

ii) Using shmget
parent.c:
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
int main(int argc, char *argv[])
{
	int i;
	pid_t pid;
	int k;
	int n1, n2, n3;
	const int SIZE = 4096;
	int shmid;
	void *ptr;
	shmid = shmget((key_t) 1122, 4096, 0666 | IPC_CREAT);
	ptr = shmat(shmid, NULL, 0666);
	if (argc > 1)
	{
		sscanf(argv[1], "%d", &i);
		if (i < 1)
		{
			printf("Error input: %d\n", i);
			return 0;
		}
	}
	else
	{
		return 1;
	}

	pid = fork();
	if (pid == 0)
	{
		execlp("./fib", "fib", argv[1], NULL);
	}
	else if (pid > 0)
	{
		wait(NULL);
		printf("\nPARENT: child completed\n");
		printf("Parent printing:\n");
		printf("%s ", (char *)ptr);
		shmdt(ptr);
	
	}
	return 0;
}

child.c:
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	int k = 2, n1, n2, n3;
	void *ptr;
	int shmid = shmget((key_t) 1122, 4096, 0666);
	ptr = shmat(shmid, NULL, 0666);
	printf("CHILD:\n");
	int i = atoi(argv[1]);
	n1 = 0;
	n2 = 1;
	sprintf(ptr, "%d ", n1);
	ptr += strlen(ptr);
	printf("%d ", n1);
	sprintf(ptr, "%d ", n2);
	ptr += strlen(ptr);
	printf("%d ", n2);
	while (k != i)
	{
	n3 = n1 + n2;
	sprintf(ptr, "%d ", n3);
	printf("%d ", n3);
	n1 = n2;
	n2 = n3;
	ptr += strlen(ptr);
	k++;
	}
	shmctl(shmid, IPC_RMID, NULL);
	return 0;
}
Output:
$ gcc parent.c
$ gcc child.c -o fib
$ ./a.out 5
CHILD:
0 1 1 2 3
PARENT: child completed
Parent printing:
0 1 1 2 3

*************************************************************************************************************
*************************************************************************************************************
#!/bin/bash
#Shell script to simulate simple calulator
echo "Enter any two non-zero numbers: "
read a b 

echo "Enter The Operator: "
echo "Addition +"
echo "Subtraction -"
echo "Product *"
echo "Division /"
read op

case $op in
'+') echo "Sum of $a and $b is : $(( a + b ))"
;;
'-') echo "Difference of $a and $b is : $(( a - b ))"
;;
'*') echo "Product of $a and $b is : $(( a * b ))"
;;
'/') echo "Division of $a and $b is : $(( a / b ))"
;;
*) echo "Invalid Input Operator"
;;
esac
***************************************************************************************************
/*A. Write a program to perform the following tasks using system calls:
i) Parent process should create a child process
ii) Both parent child processes should display their pid and parent’s pid; parent process should also its child’s pid
iii) Load a new program into child process
iv) The parent process should terminate after the child process terminates 
EXIT(),GETPID(),GETPPID(),WAIT(),SLEEP(),EXECLP()
*/

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() 
{
    pid_t child_pid, my_pid, parent_pid, wid;
    int i = 10;
    child_pid = fork();
    if (child_pid < 0) 
    {
        printf("Fork failed. Exiting!\n");
        exit(0);
    }
    if (child_pid == 0) 
    {
        // Child process
        my_pid = getpid();
        parent_pid = getppid();
        printf("[CHILD] My pid is %d\n", my_pid);
        printf("[CHILD] My parent's pid is %d\n", parent_pid);
        printf("[CHILD] i= %d\n",--i);
        printf("[CHILD] Child process going to load another program using execlp syscall\n");
        execlp("/bin/pwd", "pwd", NULL);
    } 
    else 
    {
        // Parent process
        printf("[PARENT] This is the parent process.\n");
        my_pid = getpid();
        parent_pid = getppid();
        printf("[PARENT] My pid is %d\n", my_pid);
        printf("[PARENT] Waiting for child to terminate\n");
        wid=wait(NULL);
        printf("[PARENT] Resuming after the termination of %d\n", wid);
        printf("[PARENT] My parent's pid is %d\n", parent_pid);
        printf("[PARENT] My child's pid is %d\n", child_pid);
        printf("[PARENT] i= %d\n",++i);
    }
    return 0;
}
***************************************************************************************************
/* Solution for producer-consumer problem using mutex and semaphore. 5 producers and 5 consumers are used to demonstrate the solution.*/

/*
Some important methods that can be used with semaphore in c
sem_init -> Initialise the semaphore to some initial value
sem_wait -> Same as wait() operation
sem_post -> Same as Signal() operation
sem_destroy -> Destroy the semaphore to avoid memory leak

Some important methods that can be used with mutex in c
pthread_mutex_init -> Initialise the mutex
pthread_mutex_lock() -> Same as wait() operation
pthread_mutex_unlock() -> Same as Signal() operation
pthread_mutex_destroy() -> Destroy the mutex to avoid memory leak
*/

#include <pthread.h>
#include <semaphore.h>
#include <stdlib.h>
#include <stdio.h>
#define MaxItems 5 // Maximum items a producer can produce or a consumer can consume
#define BufferSize 5 // Size of the buffer

sem_t empty;
sem_t full;
int in = 0;
int out = 0;
int buffer[BufferSize];
pthread_mutex_t mutex;

void *producer(void *pno)
{   
    int item;
    for(int i = 0; i < MaxItems; i++) {
        item = rand(); // Produce an random item
        sem_wait(&empty);
        pthread_mutex_lock(&mutex);
        buffer[in] = item;
        printf("Producer %d: Insert Item %d at %d\n", *((int *)pno),buffer[in],in);
        in = (in+1)%BufferSize;
        pthread_mutex_unlock(&mutex);
        sem_post(&full);
    }
}
void *consumer(void *cno)
{   
    for(int i = 0; i < MaxItems; i++) {
        sem_wait(&full);
        pthread_mutex_lock(&mutex);
        int item = buffer[out];
        printf("Consumer %d: Remove Item %d from %d\n",*((int *)cno),item, out);
        out = (out+1)%BufferSize;
        pthread_mutex_unlock(&mutex);
        sem_post(&empty);
    }
}
int main()
{   

    pthread_t pro[5],con[5];
    pthread_mutex_init(&mutex, NULL);
    sem_init(&empty,0,BufferSize);
    sem_init(&full,0,0);

    int a[5] = {1,2,3,4,5}; //Just used for numbering the producer and consumer

    for(int i = 0; i < 5; i++) {
        pthread_create(&pro[i], NULL, (void *)producer, (void *)&a[i]);
    }
    for(int i = 0; i < 5; i++) {
        pthread_create(&con[i], NULL, (void *)consumer, (void *)&a[i]);
    }

    for(int i = 0; i < 5; i++) {
        pthread_join(pro[i], NULL);
    }
    for(int i = 0; i < 5; i++) {
        pthread_join(con[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
    sem_destroy(&empty);
    sem_destroy(&full);

    return 0;
  }  

***************************************************************************************************
***************************************************************************************************
#!/bin/bash
#Shell script to find largest of three numbers
echo -ne "Enter any three numbers : "
read a b c
max=$a
if [ $b -gt $a ] ; then
  max=$b
fi
if [ $c -gt $a ] ; then
  max=$c
fi
echo "Largest number is $max"

***************************************************************************************************
/* Solution for first readers writers problem using mutex and semaphore. There are 10 readers and 5 writers to demonstrate the solution. */
//to compile:  gcc rw.c -pthread

/*
Some important methods that can be used with semaphore in c
sem_init -> Initialise the semaphore to some initial value
sem_wait -> Same as wait() operation
sem_post -> Same as Signal() operation
sem_destroy -> Destroy the semaphore to avoid memory leak

Some important methods that can be used with mutex in c
pthread_mutex_init -> Initialise the mutex
pthread_mutex_lock() -> Same as wait() operation
pthread_mutex_unlock() -> Same as Signal() operation
pthread_mutex_destroy() -> Destroy the mutex to avoid memory leak
*/

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

sem_t wrt;
pthread_mutex_t mutex;
int cnt = 1;
int numreader = 0;

void *writer(void *wno)
{   
    sem_wait(&wrt);
  //sem_wait(&sem_name); If the value of the semaphore is negative, the calling process blocks; 
    cnt = cnt*2;
    printf("Writer %d modified cnt to %d\n",(*((int *)wno)),cnt);
    sem_post(&wrt);
  //sem_post(&sem_name); It increments the value of the semaphore and wakes up a blocked process waiting on the semaphore, if any.

}
void *reader(void *rno)
{   
    // Reader acquire the lock before modifying numreader
    pthread_mutex_lock(&mutex);
    numreader++;
    if(numreader == 1) 
    {
        sem_wait(&wrt); // If this id the first reader, then it will block the writer
    }
    pthread_mutex_unlock(&mutex);
    // Reading Section
    printf("Reader %d: read cnt as %d\n",*((int *)rno),cnt);

    // Reader acquire the lock before modifying numreader
    pthread_mutex_lock(&mutex);
    numreader--;
    if(numreader == 0) 
    {
        sem_post(&wrt); // If this is the last reader, it will wake up the writer.
    }
    pthread_mutex_unlock(&mutex);
}

int main()
{   

    pthread_t read[10],write[5];
    pthread_mutex_init(&mutex, NULL);
//initialize a mutex to its default value
    sem_init(&wrt,0,1);
//sem_init() function initializes an unnamed semaphore and sets its initial value. Syntax: sem_init(sem_t *sem, int pshared, unsigned int value); sem ---> points to a semaphore object to initialize; pshared ---> A value of zero indicates that the semaphore will be used only by threads within the current process. A nonzero value indicates that the semaphore may be used by threads from other processes; value ---> used to initialize the value of the semaphore
    int a[10] = {1,2,3,4,5,6,7,8,9,10}; //Just used for numbering the reader and writer

    for(int i = 0; i < 10; i++) {
        pthread_create(&read[i], NULL, (void *)reader, (void *)&a[i]);
      //pthread_create(&tid, &attr, threadfun, args);
    }
    for(int i = 0; i < 5; i++) {
        pthread_create(&write[i], NULL, (void *)writer, (void *)&a[i]);
    }

    for(int i = 0; i < 10; i++) {
        pthread_join(read[i], NULL);
    }
    for(int i = 0; i < 5; i++) {
        pthread_join(write[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
//pthread_mutex_destroy() function destroys the mutex object referenced by mutex; 
    sem_destroy(&wrt);
//int sem_destroy(sem_t *sem)-->destroys the semaphore; no threads should be waiting on the semaphore if its destruction is to succeed.
    return 0;
  }
    
 
***************************************************************************************************

// C program to implement Round Robin CPU Scheduling Algorithm 

#include<stdio.h>
#include<limits.h>
#include<stdbool.h>  //for bool datatype
#include <stdlib.h> //for qsort

struct process_struct
{
  int pid;
  int at;
  int bt;
  int ct,wt,tat,rt,start_time;
  int bt_remaining;
}ps[100];


int findmax(int a, int b)
{
    return a>b?a:b;
}

int comparatorAT(const void * a, const void *b)
{
   int x =((struct process_struct *)a) -> at;
   int y =((struct process_struct *)b) -> at;
   if(x<y)
     return -1;  // No sorting
   else if( x>=y) // = is for stable sort
    return 1;    // Sort
}

int comparatorPID(const void * a, const void *b)
{
   int x =((struct process_struct *)a) -> pid;
   int y =((struct process_struct *)b) -> pid;
   if(x<y)
     return -1;  // No sorting
   else if( x>=y)
    return 1;    // Sort
}

int main()
{
    
    int n,index;
    int cpu_utilization;
    //queue<int> q;
   
    bool visited[100]={false},is_first_process=true;
    int current_time = 0,max_completion_time;
    int completed = 0,tq, total_idle_time=0,length_cycle;
    printf("Enter total number of processes: ");
    scanf("%d",&n);    
    int queue[100],front=-1,rear=-1;
    float sum_tat=0,sum_wt=0,sum_rt=0;
   

    for(int i=0;i<n;i++)
    {
        printf("\nEnter Process %d Arrival Time: ",i);
        scanf("%d",&ps[i].at);
        ps[i].pid=i;
    }
    
    for(int i=0;i<n;i++)
    {
       printf("\nEnter Process %d Burst Time: ",i); 
       scanf("%d",&ps[i].bt);
       ps[i].bt_remaining= ps[i].bt;
    }
    
    printf("\nEnter time quanta: ");
    scanf("%d",&tq);
    
    //sort structure on the basis of Arrival time in increasing order
    qsort((void *)ps,n, sizeof(struct process_struct),comparatorAT);
   // q.push(0); 
    front=rear=0;
    queue[rear]=0;    
    visited[0] = true;
   
    while(completed != n) 
    {
      index = queue[front];      
      //q.pop();
      front++;
      
      if(ps[index].bt_remaining == ps[index].bt)
      {
            ps[index].start_time = findmax(current_time,ps[index].at);
            total_idle_time += (is_first_process == true) ? 0 : ps[index].start_time - current_time;
            current_time =  ps[index].start_time;
            is_first_process = false;
             
      }

      if(ps[index].bt_remaining-tq > 0)
      {    
            ps[index].bt_remaining -= tq;
            current_time += tq;
      }
      else 
      {
            current_time += ps[index].bt_remaining;
            ps[index].bt_remaining = 0;
            completed++;

            ps[index].ct = current_time;
            ps[index].tat = ps[index].ct - ps[index].at;
            ps[index].wt = ps[index].tat - ps[index].bt;
            ps[index].rt = ps[index].start_time - ps[index].at;

            sum_tat += ps[index].tat;
            sum_wt += ps[index].wt;
            sum_rt += ps[index].rt;
             
      }


       //check which new Processes needs to be pushed to Ready Queue from Input list
      for(int i = 1; i < n; i++) 
      {
          if(ps[i].bt_remaining > 0 && ps[i].at <= current_time && visited[i] == false) 
          {
            //q.push(i);
            queue[++rear]=i;
            visited[i] = true;
          }
      }
      //check if Process on CPU needs to be pushed to Ready Queue
      if( ps[index].bt_remaining> 0) 
          //q.push(index);
          queue[++rear]=index;
    
            
      //if queue is empty, just add one process from list, whose remaining burst time > 0
      if(front>rear)
      {
          for(int i = 1; i < n; i++)
          {
            if(ps[i].bt_remaining > 0)
            {
              queue[rear++]=i;
              visited[i] = true;
              break;
            }
          }
      }
   } //end of while
   
   //Calculate Length of Process completion cycle
  max_completion_time = INT_MIN;
  
  for(int i=0;i<n;i++)
        max_completion_time = findmax(max_completion_time,ps[i].ct);
      
  length_cycle = max_completion_time - ps[0].at;  //ps[0].start_time; 
    
  cpu_utilization = (float)(length_cycle - total_idle_time)/ length_cycle;

  //sort so that process ID in output comes in Original order (just for interactivity- Not needed otherwise)  
  qsort((void *)ps,n, sizeof(struct process_struct),comparatorPID);

  //Output
  printf("\nProcess No.\tAT\tCPU Burst Time\tStart Time\tCT\tTAT\tWT\tRT\n");
  for(int i=0;i<n;i++)
    printf("%d\t\t%d\t%d\t\t%d\t\t%d\t%d\t%d\t%d\n",i,ps[i].at,ps[i].bt,ps[i].start_time,ps[i].ct,ps[i].tat,ps[i].wt,ps[i].rt);
  printf("\n");    

  printf("\nAverage Turn Around time= %.2f",(float)sum_tat/n);
  printf("\nAverage Waiting Time= %.2f",(float)sum_wt/n);
  printf("\nAverage Response Time= %.2f",(float)sum_rt/n);    
  printf("\nThroughput= %.2f",n/(float)length_cycle);
  printf("\nCPU Utilization(Percentage)= %.2f",cpu_utilization*100);
  return 0;
}

*************************************************************************************************************

